<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Form2 ‚Äì Diagnostic Analytics & Excel Export</title>
    <link rel="stylesheet" href="styles.css">
</head>

<body>

    <header>
        <h1>Stage 3 ‚Äì Form2: Diagnostic Analytics with Excel Export</h1>
        <p>Form2 is your SQL-powered diagnostic engine. It transforms saved expense records into a structured Excel workbook using queries that highlight patterns, frequency, and trends ‚Äî setting the stage for deeper visual and descriptive analytics in Form3.</p>
    </header>

    <main>

        <section>
            <h2>üéØ What Form2 Delivers</h2>
            <ul>
                <li>7 prewritten SQL queries for analyzing spending by time, category, method, and place</li>
                <li>Excel output powered by ClosedXML</li>
                <li>Pivot tables and charts to support diagnostic interpretation</li>
                <li>Data infrastructure for building Word-based reports in Form3</li>
            </ul>
        </section>

        <section>
            <h2>üì¶ Required Imports</h2>
            <pre><code>Imports ClosedXML.Excel
Imports Microsoft.Data.SqlClient</code></pre>
            <p>ClosedXML builds Excel files in memory without requiring Microsoft Office, while SqlClient enables VB.NET to execute SQL Server queries.</p>
        </section>

        <section>
            <h2>üìÅ Save Dialog Setup</h2>
            <pre><code>
Dim saveDialog As New SaveFileDialog() With {
    .Filter = "Excel Workbook (*.xlsx)|*.xlsx",
    .FileName = $"ExpenseData_{DateTime.Now:yyyyMMdd_HHmmss}.xlsx",
    .Title = "Save Expense Data"
}

If saveDialog.ShowDialog() <> DialogResult.OK Then Exit Sub
Dim fullPath As String = saveDialog.FileName
  </code></pre>
            <p><strong>Explanation:</strong> This prompts the user to select a location and name for the workbook export. The filename includes a timestamp for versioning.</p>
        </section>
        <section>
            <h2>üìë SQL Queries Used in Export</h2>
            <p>Each worksheet in the Excel workbook is generated from a different SQL query. Together, these queries form a diagnostic engine to answer: What changed? Where did spending go up? How often am I visiting certain places?</p>

            <h3>1. Weekly Spending by Category</h3>
            <pre><code>SELECT CAST(DateSpent AS DATE) AS ExpenseDate, Category, SUM(AmountSpent) AS Total
FROM Expenses
WHERE DateSpent >= DATEADD(day, -7, GETDATE())
GROUP BY CAST(DateSpent AS DATE), Category
ORDER BY ExpenseDate DESC</code></pre>
            <p>Shows recent spending by category ‚Äî useful for identifying weekly patterns and shifts.</p>

            <h3>2. Monthly Spending Trends</h3>
            <pre><code>SELECT FORMAT(DateSpent, 'MMM yyyy') AS Month, SUM(AmountSpent) AS Total
FROM Expenses
GROUP BY FORMAT(DateSpent, 'MMM yyyy')
ORDER BY MIN(DateSpent)</code></pre>
            <p>Summarizes total spending month by month to help visualize long-term trends.</p>

            <h3>3. Payment Method Share</h3>
            <pre><code>SELECT PaymentMethod, COUNT(*) AS Usage
FROM Expenses
GROUP BY PaymentMethod
ORDER BY Usage DESC</code></pre>
            <p>Breaks down how often each payment method is used ‚Äî ideal for pie chart visualizations.</p>

            <h3>4. Custom Date Range Spending</h3>
            <pre><code>SELECT CAST(DateSpent AS DATE) AS Date, SUM(AmountSpent) AS Total
FROM Expenses
GROUP BY CAST(DateSpent AS DATE)
ORDER BY Date</code></pre>
            <p>Daily total spending ‚Äî great for line graphs to see behavioral curves.</p>

            <h3>5. Inventory Overview by Date</h3>
            <pre><code>SELECT CAST(DateSpent AS DATE) AS Date, SUM(AmountSpent) AS InventoryTotal
FROM Expenses
GROUP BY CAST(DateSpent AS DATE)
ORDER BY Date</code></pre>
            <p>Alternate view of daily totals ‚Äî possibly for business or stock-related tracking.</p>

            <h3>6. Weekly Favorite Spending Place</h3>
            <pre><code>SELECT CAST(DateSpent AS DATE) AS ExpenseDate, PlaceSpent, COUNT(*) AS Visits
FROM Expenses
WHERE DateSpent >= DATEADD(day, -7, GETDATE())
  AND PlaceSpent IS NOT NULL AND PlaceSpent <> ''
GROUP BY CAST(DateSpent AS DATE), PlaceSpent
ORDER BY ExpenseDate DESC</code></pre>
            <p>Identifies your most visited vendors this week ‚Äî shows which places are drawing attention.</p>

            <h3>7. Annual Favorite Spending Place</h3>
            <pre><code>SELECT PlaceSpent, COUNT(*) AS Visits
FROM Expenses
WHERE DateSpent >= DATEADD(year, -1, GETDATE())
  AND PlaceSpent IS NOT NULL AND PlaceSpent <> ''
GROUP BY PlaceSpent
ORDER BY Visits DESC</code></pre>
            <p>Ranks the top vendors across the year ‚Äî excellent for long-term vendor diagnostics.</p>
        </section>
        <section>
            <h2>üß† How These Queries Are Written in VB.NET</h2>
            <p>In <code>Form2.vb</code>, each of the seven queries is written as a tuple inside a VB.NET array called <code>queries</code>. This array pairs the worksheet title with its associated SQL command.</p>

            <p>Here is exactly how they look in VB.NET syntax:</p>

            <pre><code>
Dim queries As (String, String)() = {
    (
        "Weekly Spending by Category",
        "SELECT CAST(DateSpent AS DATE) AS ExpenseDate, Category, SUM(AmountSpent) AS Total " &
        "FROM Expenses " &
        "WHERE DateSpent >= DATEADD(day, -7, GETDATE()) " &
        "GROUP BY CAST(DateSpent AS DATE), Category " &
        "ORDER BY ExpenseDate DESC"
    ),
    (
        "Monthly Spending Trends",
        "SELECT FORMAT(DateSpent, 'MMM yyyy') AS Month, SUM(AmountSpent) AS Total " &
        "FROM Expenses " &
        "GROUP BY FORMAT(DateSpent, 'MMM yyyy') " &
        "ORDER BY MIN(DateSpent)"
    ),
    (
        "Payment Method Share",
        "SELECT PaymentMethod, COUNT(*) AS Usage " &
        "FROM Expenses " &
        "GROUP BY PaymentMethod " &
        "ORDER BY Usage DESC"
    ),
    (
        "Custom Date Range Spending",
        "SELECT CAST(DateSpent AS DATE) AS Date, SUM(AmountSpent) AS Total " &
        "FROM Expenses " &
        "GROUP BY CAST(DateSpent AS DATE) " &
        "ORDER BY Date"
    ),
    (
        "Inventory Overview by Date",
        "SELECT CAST(DateSpent AS DATE) AS Date, SUM(AmountSpent) AS InventoryTotal " &
        "FROM Expenses " &
        "GROUP BY CAST(DateSpent AS DATE) " &
        "ORDER BY Date"
    ),
    (
        "Weekly Favorite Spending Place",
        "SELECT CAST(DateSpent AS DATE) AS ExpenseDate, PlaceSpent, COUNT(*) AS Visits " &
        "FROM Expenses " &
        "WHERE DateSpent >= DATEADD(day, -7, GETDATE()) " &
        "AND PlaceSpent IS NOT NULL AND PlaceSpent <> '' " &
        "GROUP BY CAST(DateSpent AS DATE), PlaceSpent " &
        "ORDER BY ExpenseDate DESC"
    ),
    (
        "Annual Favorite Spending Place",
        "SELECT PlaceSpent, COUNT(*) AS Visits " &
        "FROM Expenses " &
        "WHERE DateSpent >= DATEADD(year, -1, GETDATE()) " &
        "AND PlaceSpent IS NOT NULL AND PlaceSpent <> '' " &
        "GROUP BY PlaceSpent " &
        "ORDER BY Visits DESC"
    )
}
  </code></pre>

            <p><strong>Explanation:</strong> Each SQL statement is enclosed in quotation marks and concatenated across lines using <code>&</code>. This ensures readability in code while safely preserving formatting.</p>

            <p>Later in the export loop, each query in <code>queries(i).Item2</code> is executed using <code>SqlCommand</code> and exported to the corresponding worksheet <code>queries(i).Item1</code>.</p>
        </section>

        <section>
            <h2>üöÄ Starting the Export Logic in VB.NET</h2>
            <pre><code>Using workbook As New XLWorkbook()
    Dim queries As (String, String)() = { ... } ' Contains all 7 query-title pairs
    Dim connStr As String = My.Settings.DbConnectionString

    Using conn As New SqlConnection(connStr)
        conn.Open()</code></pre>
            <p><strong>Explanation:</strong> We create a blank Excel workbook, access our SQL Server connection, and prepare to execute each query and write the results to a worksheet.</p>
        </section>
        <section>
            <h2>üßÆ Writing Query Results to Excel</h2>
            <pre><code>
        For i As Integer = 0 To queries.Length - 1
            Dim sheetName = $"Sheet{i + 1}"
            Dim worksheet = workbook.Worksheets.Add(sheetName)

            worksheet.Cell(1, 1).Value = queries(i).Item1
            worksheet.Cell(1, 1).Style.Font.Bold = True

            Dim dt As New DataTable()
            Using cmd As New SqlCommand(queries(i).Item2, conn)
                Using da As New SqlDataAdapter(cmd)
                    da.Fill(dt)
                End Using
            End Using

            ' Write column headers
            For col = 0 To dt.Columns.Count - 1
                worksheet.Cell(2, col + 1).Value = dt.Columns(col).ColumnName
                worksheet.Cell(2, col + 1).Style.Font.Bold = True
            Next

            ' Write row data with type-aware formatting
            For row = 0 To dt.Rows.Count - 1
                For col = 0 To dt.Columns.Count - 1
                    Dim cellValue = dt.Rows(row)(col)
                    If TypeOf cellValue Is String Then
                        worksheet.Cell(row + 3, col + 1).Value = cellValue.ToString()
                    ElseIf TypeOf cellValue Is Decimal Or TypeOf cellValue Is Double Then
                        worksheet.Cell(row + 3, col + 1).Value = Convert.ToDouble(cellValue)
                    ElseIf TypeOf cellValue Is Integer Then
                        worksheet.Cell(row + 3, col + 1).Value = Convert.ToInt32(cellValue)
                    ElseIf TypeOf cellValue Is DateTime Then
                        worksheet.Cell(row + 3, col + 1).Value = CType(cellValue, DateTime).ToString("yyyy-MM-dd")
                    Else
                        worksheet.Cell(row + 3, col + 1).Value = cellValue?.ToString()
                    End If
                Next
            Next

            worksheet.Columns().AdjustToContents()
        Next
  </code></pre>

            <p><strong>Explanation:</strong> This loop creates one sheet per query. It writes headers and rows using .NET‚Äôs DataTable object, and adjusts every column width to match the content.</p>
        </section>

        <section>
            <h2>üíæ Saving the Workbook</h2>
            <pre><code>
    End Using ' end SqlConnection
    workbook.SaveAs(fullPath)
End Using ' end XLWorkbook

MessageBox.Show("Data exported successfully to " & fullPath, "Export Complete", MessageBoxButtons.OK,<br /> MessageBoxIcon.Information)
  </code></pre>
            <p><strong>Explanation:</strong> After all worksheets are created, the file is saved to disk and the user is notified. The workbook is clean, timestamped, and analysis-ready.</p>
        </section>
        <section>
            <h2>üìä Turning Worksheets into Dashboards</h2>
            <p>Once you've exported your workbook, it's time to visualize:</p>
            <ol>
                <li>Open the file and navigate to a worksheet (e.g., ‚ÄúSheet1‚Äù)</li>
                <li>Select the full table (including headers)</li>
                <li>Go to <strong>Insert ‚Üí Pivot Table</strong> or <strong>Insert ‚Üí Chart</strong></li>
                <li>
                    Experiment with:
                    <ul>
                        <li><code>Line Charts</code> for date-based spending trends</li>
                        <li><code>Pie Charts</code> to show payment method distribution</li>
                        <li><code>Bar Charts</code> to compare category totals</li>
                    </ul>
                </li>
                <li>
                    To summarize everything visually:
                    <ul>
                        <li>Create a new sheet called <code>Dashboard</code></li>
                        <li>Paste your most important charts here for a single visual summary</li>
                    </ul>
                </li>
            </ol>
            <p><strong>This is diagnostic analytics in action:</strong> you're exploring patterns to explain what‚Äôs changing and why. It creates the story behind the data that Form3 will present.</p>
        </section>

        <section>
            <h2>üß≠ Review: What Form2 Achieves</h2>
            <ul>
                <li>Extracts structured summaries using SQL</li>
                <li>Empowers users to build Excel dashboards and visual insight</li>
                <li>Acts as a diagnostic engine between raw transactions and descriptive reporting</li>
                <li>Bridges Form1 (data capture) and Form3 (report generation)</li>
            </ul>
            <p>This is where learners transform from <em>data collectors</em> to <em>data interpreters</em>.</p>
        </section>

        <section>
            <h2>üìö What Comes Next in Form3</h2>
            <p>In <strong>Form3</strong>, you'll choose high-value insights and export them into a styled <code>.docx</code> Word report. This is the descriptive stage ‚Äî summarizing the "what" for presentation or publication. The transition from grid to narrative begins.</p>
        </section>

    </main>

    <footer>
        <p>SQL Craft Academy &copy; 2025 | Learning Beyond Limits</p>
    </footer>

</body>
</html>